{"componentChunkName":"component---src-templates-blog-jsx","path":"/blog/failed-to-grpc-with-nlb/","result":{"data":{"markdownRemark":{"fields":{"urlPath":"/blog/failed-to-grpc-with-nlb/","jstDate":"2017-10-22"},"html":"<p>先日発表された AWS の Network Load Balancer (NLB) を gRPC で使ってみたのですが、 idle timeout 周りで盛大にミスったので知見共有です。</p>\n<!--more-->\n<h2>経緯</h2>\n<p>先日、 NLB こと Network Load Balancer が AWS にてリリースされました。</p>\n<blockquote>\n<p><a href=\"https://aws.amazon.com/jp/blogs/news/new-network-load-balancer-effortless-scaling-to-millions-of-requests-per-second/\">新しいNetwork Load Balancer – 秒間数百万リクエストに簡単にスケーリング | Amazon Web Services ブログ</a></p>\n</blockquote>\n<p>NLB は TCP レベルでのロードバランシングができ、プレウォーミングなしで高パフォーマンスを発揮できるため既存のAWS の LB に比べ gRPC との相性が良いです。</p>\n<p>マイクロサービス構成を取っている生放送サービスにて gRPC の経路に NLB を導入したのですが、一部のサービスにて接続エラーが生じるようになったので知見を共有いたします。</p>\n<h2>症状</h2>\n<ul>\n<li>一部のサービスにて <code class=\"language-text\">rpc error: code = Unavailable desc = transport is closing</code> のようなエラーが生じた</li>\n<li>Go のサービスだけでなく、 Java のサービスでも生じた</li>\n<li>頻繁に gRPC 通信をしない経路にて生じている様子</li>\n<li>NLB を通さず Client - Server を直結した場合は生じない</li>\n<li>NLB の Monitoring を見たところ、 <code class=\"language-text\">TCP_ELB_Reset_Count</code> が入っている</li>\n</ul>\n<h2>原因</h2>\n<p>ドキュメントに記載がありました（現在は英語版ドキュメントのみ）</p>\n<blockquote>\n<p>Connection Idle Timeout</p>\n<p>For each request that a client makes through a load balancer, the load balancer maintains two connections. A front-end connection is between a client and the load balancer, and a back-end connection is between the load balancer and a target. For each front-end connection, the load balancer manages an idle timeout that is triggered when no data is sent over the connection for a specified time period. If no data has been sent or received by the time that the idle timeout period elapses, the front-end connection is broken. If a client sends data after the idle timeout period has elapses, it receives a TCP RST packet to indicate that the connection is no longer valid.</p>\n<p>Elastic Load Balancing sets the idle timeout value to 350 seconds. You cannot modify this value. Your targets can use TCP keepalive packets to reset the idle timeout.</p>\n<blockquote>\n<p><a href=\"http://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#connection-idle-timeout\">Network Load Balancers - Elastic Load Balancing</a></p>\n</blockquote>\n</blockquote>\n<p><code class=\"language-text\">TCP_ELB_Reset_Count</code> が計測されていることからも分かる通り、 350s 以上 idle している connection は NLB 側から RST Packet （\nRESET 用の packet ）を送出して接続を切るようです。</p>\n<p>よって通信頻度の低いサービスにて久々に通信しようとすると接続が切断されており、エラーが生じたというのが原因と思われます。</p>\n<h2>対応</h2>\n<p>まず Client 側に Keepalive の設定を入れました。</p>\n<p>Client のサンプルとして Go と Java を載せておきます。</p>\n<p>Go</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">Dial</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">,</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">WithKeepaliveParams</span><span class=\"token punctuation\">(</span>keepalive<span class=\"token punctuation\">.</span>ClientParameters<span class=\"token punctuation\">{</span>\n    Time<span class=\"token punctuation\">:</span>                <span class=\"token number\">150</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">,</span>\n    PermitWithoutStream<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><a href=\"https://github.com/grpc/grpc-go/blob/a5986a5c88227370a9c0a82e5277167229c034cd/keepalive/keepalive.go#L31-L39\">grpc-go/keepalive.go at master · grpc/grpc-go</a></p>\n<p>Java</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">return</span> <span class=\"token class-name\">NettyChannelBuilder</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">forAddress</span><span class=\"token punctuation\">(</span>hostName<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">enableKeepAlive</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">keepAliveTime</span><span class=\"token punctuation\">(</span><span class=\"token number\">150</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">keepAliveWithoutCalls</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n    <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>timeout が 350s なので半分弱くらいの 150s にしておきました。</p>\n<p>これで Client 側が 350s で切断される問題は解消したのですが、検証していたところなぜか 10min - 20min くらいの idle で切断される場合があることがわかりました。</p>\n<p>Server 側にも Keepalive の設定を追加することで解消しました。 Server は Go です。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">server <span class=\"token operator\">:=</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">NewServer</span><span class=\"token punctuation\">(</span>\n    grpc<span class=\"token punctuation\">.</span><span class=\"token function\">KeepaliveParams</span><span class=\"token punctuation\">(</span>keepalive<span class=\"token punctuation\">.</span>ServerParameters<span class=\"token punctuation\">{</span>\n        Time<span class=\"token punctuation\">:</span> <span class=\"token number\">150</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>ここまでの対応で今のところ安定しております。</p>\n<h2>残る疑問点</h2>\n<p>とりあえずエラーは静まったのですが、把握しきれていないことが何点かあるのでメモしておきます。</p>\n<p>もし詳細をご存じの方、把握できた方がいらっしゃいましたらご教示願えると嬉しいです！</p>\n<h3>Keepalive を短時間にすることの弊害</h3>\n<p>今のところ問題なさそうですが、負荷などへの影響をちゃんと検証していないので不明です。</p>\n<h3>10min - 20min で切断される現象</h3>\n<p>何が原因なのかよくわかっておらず。検証した条件を載せておきます。</p>\n<ul>\n<li>1min, 5min, 6min, 10min, 20min, 30min 間隔で通信を行う6 connection を、並列して1台のサーバに対し接続した場合、 20min 以上でエラー</li>\n<li>NLB 経由せず Client - Server を直結した場合は生じない</li>\n</ul>\n<p>解せぬ。</p>\n<h3>EnforcementPolicy の挙動</h3>\n<p>Server 側に EnforcementPolicy という設定がありまして、頻繁すぎる Keepalive を許容しないようにできるっぽいです。</p>\n<blockquote>\n<p><a href=\"https://github.com/grpc/grpc-go/blob/a5986a5c88227370a9c0a82e5277167229c034cd/keepalive/keepalive.go#L58-L65\">grpc-go/keepalive.go at master · grpc/grpc-go</a></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// EnforcementPolicy is used to set keepalive enforcement policy on the server-side.</span>\n<span class=\"token comment\">// Server will close connection with a client that violates this policy.</span>\n<span class=\"token keyword\">type</span> EnforcementPolicy <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// MinTime is the minimum amount of time a client should wait before sending a keepalive ping.</span>\n\tMinTime time<span class=\"token punctuation\">.</span>Duration <span class=\"token comment\">// The current default value is 5 minutes.</span>\n\t<span class=\"token comment\">// If true, server expects keepalive pings even when there are no active streams(RPCs).</span>\n\tPermitWithoutStream <span class=\"token builtin\">bool</span> <span class=\"token comment\">// false by default.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">MinTime</code> 以下の Keepalive 間隔の Client がいた場合、接続を拒否するような設定に見えます。</p>\n<p>デフォルト値が 5min なので今回の 150s 設定だと切断されそうに思えるのですが、普通に接続されました。今後のバージョンアップで挙動が変わる可能性もあるので、正解を把握しておきたいところ。</p>\n<h2>以上</h2>\n<p>検証が済んでいなかったり最適設定といいきれる状態までまとめられていないのですが、 NLB 導入時に踏みそうな症状なのでいったん共有です。</p>\n<p>idle が長い connection に心あたりがある場合は検証してから本番導入をおすすめします。</p>","excerpt":"先日発表された AWS の Network Load Balancer (NLB) を gRPC で使ってみたのですが、 idle timeout 周りで盛大にミスったので知見共有です。","frontmatter":{"date":"2017-10-22T17:00:00+09:00","title":"gRPC with NLB は idle timeout に気をつけないと死ぬ","tags":["Development","AWS","NLB","gRPC"],"eyecatch":null}}},"pageContext":{"urlPath":"/blog/failed-to-grpc-with-nlb/","previous":{"fields":{"urlPath":"/blog/cago-2-x-sync/","jstDate":"2017-09-06"},"frontmatter":{"title":"CA.go #2 で golang.org/x/sync について喋りました #ca_go","date":"2017-09-06"}},"next":{"fields":{"urlPath":"/blog/golang-channel-pattern/","jstDate":"2017-12-01"},"frontmatter":{"title":"Go の channel 処理パターン集","date":"2017-11-30"}}}},"staticQueryHashes":["1862978031","277821901","4270455655"]}