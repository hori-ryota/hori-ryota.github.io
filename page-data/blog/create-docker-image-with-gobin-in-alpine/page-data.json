{"componentChunkName":"component---src-templates-blog-jsx","path":"/blog/create-docker-image-with-gobin-in-alpine/","result":{"data":{"markdownRemark":{"fields":{"urlPath":"/blog/create-docker-image-with-gobin-in-alpine/"},"html":"<p><a href=\"http://blog.stormcat.io/post/entry/go-binary-alpine\">go getで取得したcliツールのバイナリを持った軽量なDockerイメージをつくる - tehepero note(・ω&#x3C;)</a> を読んで、別解として Docker in Docker で作れないかなーと思ってやってみました。</p>\n<!--more-->\n<h2>やりたいこと</h2>\n<p>根本的な動機は元記事をご参照ください。</p>\n<blockquote>\n<p><a href=\"http://blog.stormcat.io/post/entry/go-binary-alpine\">go getで取得したcliツールのバイナリを持った軽量なDockerイメージをつくる - tehepero note(・ω&#x3C;)</a></p>\n</blockquote>\n<p>元記事では Alpine ベースの golang イメージで <code class=\"language-text\">go get</code> したバイナリを <code class=\"language-text\">docker cp</code> で取得し、実行用のイメージを作成するフローを CircleCI で実行しています。</p>\n<p>この記事では CI を用いずに Docker in Docker なビルド用のイメージを用いることでコンテナ内で <code class=\"language-text\">go get</code> から <code class=\"language-text\">docker build</code> まで済ませてみようかと思います。</p>\n<p>なお、 <code class=\"language-text\">docker push</code> せずに成果物のイメージを取り出したかったので、今回は Docker のデーモンを起動せずにホストの <code class=\"language-text\">/var/run/docker.sock</code> をコンテナと共有します。</p>\n<h2>実行用のイメージ</h2>\n<p>先に実行用イメージ作成の構成を説明したほうがわかりやすいので、ビルド用イメージの解説の前にぺろっと紹介。</p>\n<p>ディレクトリ構成はこんな感じです。</p>\n\n        <div class=\"gatsby-code-title\">\n          <span>directory-structure</span>\n        </div>\n       \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Dockerfile\npre.sh*</code></pre></div>\n<p><code class=\"language-text\">pre.sh</code> で下準備をして、 <code class=\"language-text\">Dockerfile</code> を <code class=\"language-text\">docker build</code> する想定です。</p>\n<p>今回は <code class=\"language-text\">goose</code> のバイナリを入れたいので、下準備は <code class=\"language-text\">go get</code> です。</p>\n<p><code class=\"language-text\">pre.sh</code> は以下。</p>\n\n        <div class=\"gatsby-code-title\">\n          <span>pre.sh</span>\n        </div>\n       \n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\">#/bin/bash</span>\n\ngo get -v bitbucket.org/liamstask/goose/cmd/goose\n<span class=\"token function\">cp</span> <span class=\"token variable\">$GOPATH</span>/bin/goose ./goose</code></pre></div>\n<p><code class=\"language-text\">goose</code> のバイナリがカレントディレクトリに配置されます。</p>\n<p>Dockerfile はバイナリをコピーするだけ。</p>\n\n        <div class=\"gatsby-code-title\">\n          <span>Dockerfile</span>\n        </div>\n       \n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> alpine<span class=\"token punctuation\">:</span>3.5\n\n<span class=\"token keyword\">COPY</span> ./goose /usr/local/bin/\n\n<span class=\"token keyword\">ENTRYPOINT</span> goose</code></pre></div>\n<p>この実行用のイメージのビルドを Alpine ベースの Docker コンテナ内で実行するのが目標です。</p>\n<h2>ビルド用のイメージ</h2>\n<p>Docker のイメージ作成は依存系の解決と実行用のアレコレ配置を別イメージにするのが好きなので、二段階でやります。</p>\n<p>（ CI 等、キャッシュがない環境で依存系のビルドが何度も走るとしんどいという理由）</p>\n<h3>Docker in Docker with golang のイメージ</h3>\n<p>下準備で Docker と golang の入った Docker イメージを用意します。</p>\n<p>今回はバージョンにこだわらずに Docker のベースイメージに <code class=\"language-text\">apk</code> で取れる <code class=\"language-text\">go</code> を入れます。（記事作成時点では <code class=\"language-text\">1.7.3</code> でした）</p>\n<p>もし最新バージョンの golang を入れたい場合は golang の公式イメージの Dockerfile を参考にするのがいいかと。</p>\n\n        <div class=\"gatsby-code-title\">\n          <span>Dockerfile</span>\n        </div>\n       \n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> docker\n\n<span class=\"token keyword\">RUN</span> \\\n      apk <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>no<span class=\"token punctuation\">-</span>cache <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>update add \\\n      build<span class=\"token punctuation\">-</span>base \\\n      git \\\n      go \\\n      &amp;&amp; \\\n      mkdir /go\n\n<span class=\"token keyword\">ENV</span> GOPATH /go\n<span class=\"token keyword\">ENV</span> PATH $PATH<span class=\"token punctuation\">:</span>$GOPATH/bin</code></pre></div>\n<p>こちらを</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker build -t horiryota/docker-golang <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>として下準備。</p>\n<h3>ビルド用のイメージ</h3>\n<p>本題です。</p>\n<p>ビルド用イメージ作成用のディレクトリはこんな感じです。</p>\n\n        <div class=\"gatsby-code-title\">\n          <span>directory-structure-for-build-image</span>\n        </div>\n       \n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">build.sh*\nDockerfile\nusage.sh*</code></pre></div>\n<p>核となる <code class=\"language-text\">build.sh</code> は</p>\n\n        <div class=\"gatsby-code-title\">\n          <span>build.sh</span>\n        </div>\n       \n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\">#/bin/bash</span>\n\n<span class=\"token assign-left variable\">srcDir</span><span class=\"token operator\">=</span><span class=\"token string\">'/srcDir'</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -z <span class=\"token string\">\"<span class=\"token variable\">$IMAGE_NAME</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'<span class=\"token variable\">$IMAGE_NAME</span> unbound'</span>\n  usage.sh\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> -d <span class=\"token string\">\"<span class=\"token variable\">${srcDir}</span>\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'srcDir not found'</span>\n  usage.sh\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> -r <span class=\"token string\">\"<span class=\"token variable\">${srcDir}</span>/Dockerfile\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'Dockerfile not found'</span>\n  usage.sh\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> -r <span class=\"token string\">\"<span class=\"token variable\">${srcDir}</span>/pre.sh\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'pre.sh not found'</span>\n  usage.sh\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token function\">cp</span> -R /srcDir/* ./\n\n./pre.sh <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>\n  docker build -t <span class=\"token variable\">$IMAGE_NAME</span> <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>です。</p>\n<p>つらつら書いている <code class=\"language-text\">if</code> 文は必要なものが存在するかのチェックです。</p>\n<p>最終的にはビルド用イメージを <code class=\"language-text\">doker run</code> する際に <code class=\"language-text\">/srcDir</code> に <code class=\"language-text\">Dockerfile</code> と <code class=\"language-text\">pre.sh</code> の入ったディレクトリをマウントすることで、 <code class=\"language-text\">pre.sh</code> を実行した後に <code class=\"language-text\">docker build</code> する構成です。</p>\n<p>mount する <code class=\"language-text\">/srcDir</code> を荒らさないよう、ファイルは <code class=\"language-text\">./</code> にコピーしています。</p>\n<p><code class=\"language-text\">usage.sh</code> はイメージの使い方が出力されるだけのスクリプトなので割愛。</p>\n<p>Dockerfile は以下です。</p>\n\n        <div class=\"gatsby-code-title\">\n          <span>Dockerfile</span>\n        </div>\n       \n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> horiryota/docker<span class=\"token punctuation\">-</span>golang\n\n<span class=\"token keyword\">WORKDIR</span> /workdir\n\n<span class=\"token keyword\">COPY</span> usage.sh /usr/local/bin/\n<span class=\"token keyword\">COPY</span> build.sh /usr/local/bin/\n\n<span class=\"token keyword\">ENTRYPOINT</span> <span class=\"token string\">\"build.sh\"</span></code></pre></div>\n<p><code class=\"language-text\">build.sh</code> を発火するだけです。</p>\n<p><code class=\"language-text\">WORKDIR /workdir</code> にしているのは <code class=\"language-text\">/</code> ディレクトリにある Dockerfile で <code class=\"language-text\">docker build</code> をしようとすると権限問題で失敗するためです。</p>\n<p>ビルド用イメージのビルドをして準備完了です。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker build -t horiryota/docker-golang-builder <span class=\"token builtin class-name\">.</span></code></pre></div>\n<h2>作成実行</h2>\n<p>実行コマンドはこんな感じ。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker run --privileged -v /var/run/docker.sock:/var/run/docker.sock -v <span class=\"token variable\">$DOCKERFILE_DIR</span>:/srcDir:ro -e <span class=\"token assign-left variable\">IMAGE_NAME</span><span class=\"token operator\">=</span><span class=\"token variable\">$IMAGE_NAME</span> horiryota/docker-golang-builder</code></pre></div>\n<p>今回は <code class=\"language-text\">/var/run/docker.sock</code> を mount したのでホストの docker にイメージが生成されます。</p>\n<ul>\n<li><code class=\"language-text\">$DOCKERFILE_DIR</code> 実行用イメージ作成用のファイルがあるディレクトリ。カレントディレクトリであれば <code class=\"language-text\">$(pwd)</code> でできるかなと</li>\n<li><code class=\"language-text\">$IMAGE_NAME</code> 作成したいイメージ名。 <code class=\"language-text\">build.sh</code> の <code class=\"language-text\">docker build -t $IMAGE_NAME</code> で使うのでお好きに。</li>\n</ul>\n<p>ちなみに <code class=\"language-text\">/srcDir</code> の mount で後ろについている <code class=\"language-text\">:ro</code> は read only の意味です。ホストのディレクトリを不用意に荒らさないで済むので付けておくことを推奨します。</p>\n<p>ということで、カレントディレクトリで <code class=\"language-text\">horiryota/docker-goose</code> のイメージを作成するならこんな感じでしょうか。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker run --privileged -v /var/run/docker.sock:/var/run/docker.sock -v <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>:/srcDir:ro -e <span class=\"token assign-left variable\">IMAGE_NAME</span><span class=\"token operator\">=</span>horiryota/docker-goose horiryota/docker-golang-builder</code></pre></div>\n<h2>生成イメージの確認</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">REPOSITORY              TAG     IMAGE ID      CREATED            SIZE\nhoriryota/docker-goose  latest  fa633023a994  About an hour ago  17.4 MB</code></pre></div>\n<p>諸々のバージョンが違うので同じにはなりませんでしたが、およそ元記事と同じくらいのイメージサイズになったことが確認できました。</p>\n<h2>今回のコード</h2>\n<p>使ったコードを公開しておきます。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://github.com/hori-ryota/docker-golang\">hori-ryota/docker-golang</a></li>\n<li><a href=\"https://github.com/hori-ryota/docker-golang-bulider\">hori-ryota/docker-golang-bulider</a></li>\n<li><a href=\"https://github.com/hori-ryota/goose-docker\">hori-ryota/goose-docker</a></li>\n</ul>\n</blockquote>\n<h2>以上</h2>\n<p>Docker のコンテナ内で <code class=\"language-text\">docker build</code> することで <code class=\"language-text\">Alpine</code> ベースの軽量イメージが作成できました。</p>\n<p>Docker in Docker で準備用のスクリプトと Dockerfile を実行するのが主旨なので、 golang のバイナリ用以外にも汎用的にビルドに使えるようにできたんじゃないかなーと思っています。</p>\n<p>ちなみに Docker ベースのイメージを使わなくともホストの <code class=\"language-text\">/usr/bin/docker</code> をコンテナに mount するという手もあるようですが荒業感が強すぎるので止めました（ Docker for Mac だと <code class=\"language-text\">/usr</code> 以下を mount しようとすると怒られる模様）。</p>\n<p>コンテナ内で Docker のデーモンを立ち上げれば <code class=\"language-text\">/var/run/docker.sock</code> を mount しなくても <code class=\"language-text\">docker push</code> までコンテナ内で完結できるはずなので、必要にかられたら試してみます。</p>","excerpt":"go getで取得したcliツールのバイナリを持った軽量なDockerイメージをつくる - tehepero note(・ω<) を読んで、別解として Docker in Docker で作れないかなーと思ってやってみました。","frontmatter":{"date":"2017-02-24","title":"Docker in Docker で Go 製のバイナリを持った軽量な Docker イメージを作る","tags":["Development","Docker","Alpine","Go"],"eyecatch":null}}},"pageContext":{"urlPath":"/blog/create-docker-image-with-gobin-in-alpine/","previous":{"fields":{"urlPath":"/blog/golang-highly-versatile-method-with-arbitary-options/"},"frontmatter":{"title":"golang で汎用的な任意数のオプションを取るメソッドの作り方","date":"2017-02-21"}},"next":{"fields":{"urlPath":"/blog/ffmpeg-imagemagick-scene-detection/"},"frontmatter":{"title":"FFmpeg と ImageMagick によるサムネイルを用いた動画のシーン検出","date":"2017-02-27"}}}},"staticQueryHashes":["2432199166","277821901","3202776293"]}